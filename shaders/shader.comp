#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

layout(std430, binding = 0) buffer outputBuffer
{
	uint imageData[];
};



void writeColor(vec3 color){
	imageData[800 * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x] = packUnorm4x8(vec4(color, 1.0));
}



float lengthSquared(vec3 v){
	return v.x * v.x + v.y * v.y + v.z * v.z;
}

struct Ray {
	vec3 origin;
	vec3 direction;
};

vec3 at(Ray r, float t){
	return r.origin + r.direction * t;
}

struct HitRecord {
	vec3 p;
	vec3 normal;
	float t;
	bool frontFace;
};

void setFaceNormal(inout HitRecord record, Ray r, vec3 outwardNormal){
	record.frontFace = dot(r.direction, outwardNormal) < 0.0;
	record.normal = record.frontFace ? outwardNormal : -outwardNormal;
}

struct Sphere {
	vec3 center;
	float radius;
};

bool hit(Sphere s, Ray r, float tmin, float tmax, inout HitRecord rec) {
	vec3 oc = r.origin - s.center;
	float a = lengthSquared(r.direction);
	float half_b = dot(oc, r.direction);
	float c = lengthSquared(oc) - s.radius * s.radius;

	float discriminant = half_b * half_b - a * c;
	if(discriminant < 0.0) return false;
	float sqrtd = sqrt(discriminant);

	float root = (-half_b - sqrtd) / a;
	if(root < tmin || tmax < root){
		root = (-half_b + sqrtd) / a;
		if(root < tmin || tmax < root){
			return false;
		}
	}

	rec.t = root;
	rec.p = at(r, rec.t);
	vec3 outwardNormal = (rec.p - s.center) / s.radius;
	setFaceNormal(rec, r, outwardNormal);

	return true;
}

struct HittableList {
	Sphere spheres[2];
};

void initHittableList(inout HittableList list){
	list.spheres[0].center = vec3(0.0, 0.0, -1.0);
	list.spheres[0].radius = 0.5;

	list.spheres[1].center = vec3(0.0, -100.5, -1.0);
	list.spheres[1].radius = 100;
}

bool hitHittableList(HittableList list, Ray r, float tmin, float tmax, inout HitRecord rec){
	HitRecord tempRec;
	bool hitAnything = false;
	float closestSoFar = tmax;
	for(int i = 0; i < 2; i++){
		if (hit(list.spheres[i], r, tmin, closestSoFar, tempRec)){
			hitAnything = true;
			closestSoFar = tempRec.t;
			rec = tempRec;
		}
	}
	return hitAnything;
}

vec3 rayColor(Ray r) {
	HitRecord rec;
	HittableList list;
	initHittableList(list);
	if(hitHittableList(list, r, 0.001, 1000.0, rec)){
		return 0.5 * (rec.normal + vec3(1.0));
	}
	vec3 unitDirection = normalize(r.direction);
	float t = 0.5 * (unitDirection.y + 1.0);
	return (1.0 - t) * vec3(1.0) + t * vec3(0.5, 0.7, 1.0);
}

void main() {
	if(gl_GlobalInvocationID.x >= 800 || gl_GlobalInvocationID.y >= 600)
	return;

	float x = float(gl_GlobalInvocationID.x) / float(800 - 1);
	float y = float(gl_GlobalInvocationID.y) / float(600 - 1);

	float viewportHeight = 2.0;
	float viewportWidth = (800.0 / 600.0) * viewportHeight;
	float focalLength = 1.0;

	vec3 origin = vec3(0.0);
	vec3 horizontal = vec3(viewportWidth, 0.0, 0.0);
	vec3 vertical = vec3(0.0, viewportHeight, 0.0);
	vec3 lowerLeftCorner = origin - horizontal / 2.0 - vertical / 2.0 - vec3(0.0, 0.0, focalLength);

	Ray r;
	r.origin = origin;
	r.direction = lowerLeftCorner + x * horizontal + y * vertical - origin;
	vec3 color = rayColor(r);
	writeColor(vec3(color));
}